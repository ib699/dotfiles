/*******************************************************
This program was created by the
CodeWizardAVR V3.12 Advanced
Automatic Program Generator
© Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : 
Version : 
Date    : 6/10/2017
Author  : 
Company : 
Comments: 


Chip type               : ATmega16A
Program type            : Application
AVR Core Clock frequency: 1.000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 256
*******************************************************/

#include <mega16a.h>
#include <delay.h>
#include <string.h>
#include <stdio.h>

#define E 5
#define RW 4
#define RS 3

#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)
#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
// USART Receiver buffer
#define RX_BUFFER_SIZE 8
char rx_buffer[RX_BUFFER_SIZE];
#if RX_BUFFER_SIZE <= 256
unsigned char rx_wr_index=0,rx_rd_index=0;
#else
unsigned int rx_wr_index=0,rx_rd_index=0;
#endif
#if RX_BUFFER_SIZE < 256
unsigned char rx_counter=0;
#else
unsigned int rx_counter=0;
#endif
// This flag is set on USART Receiver buffer overflow
bit rx_buffer_overflow;
// USART Receiver interrupt service routine




char string[32];
unsigned char raw[32]={0};
int rawcounter=0;
void write_raw(unsigned char data[]);
void write_data(unsigned char data);
void screenReset();
unsigned char read_data();

interrupt [USART_RXC] void usart_rx_isr(void)
{
char status,data;
status=UCSRA;
data=UDR;
                                               
write_data(UDR);

PORTD.6=0;

if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
   {
   rx_buffer[rx_wr_index++]=data;
#if RX_BUFFER_SIZE == 256
   // special case for receiver buffer size=256
   if (++rx_counter == 0) rx_buffer_overflow=1;
#else
   if (rx_wr_index == RX_BUFFER_SIZE) rx_wr_index=0;
   if (++rx_counter == RX_BUFFER_SIZE)
      {
      rx_counter=0;
      rx_buffer_overflow=1;
      }
#endif
   }
}
#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
char data;
while (rx_counter==0);
data=rx_buffer[rx_rd_index++];
#if RX_BUFFER_SIZE != 256
if (rx_rd_index == RX_BUFFER_SIZE) rx_rd_index=0;
#endif
#asm("cli")
--rx_counter;
#asm("sei")
return data;
}
#pragma used-
#endif
// Declare your global variables here

//WARNING: This Font is usable only with MikroE GLCD Lib.
//         X-GLCD Lib does not handle this font.

//Font Generated by MikroElektronika GLCD Font Creator 1.2.0.0
//MikroeElektronika 2011 
//http://www.mikroe.com 

//GLCD FontName : Arial8x8
//GLCD FontSize : 8 x 8

const unsigned short Arial[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char  
        0x00, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char !
        0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,  // Code for char "
        0x00, 0xE4, 0x3C, 0xE7, 0x3C, 0x27, 0x00, 0x00,  // Code for char #
        0x00, 0x46, 0x89, 0xFF, 0x89, 0x72, 0x00, 0x00,  // Code for char $
        0x00, 0x06, 0x09, 0x89, 0x66, 0x18, 0x66, 0x91,  // Code for char %
        0x00, 0x60, 0x96, 0x89, 0x99, 0x66, 0xA0, 0x00,  // Code for char &
        0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char '
        0x00, 0xFC, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,  // Code for char (
        0x00, 0x01, 0x02, 0xFC, 0x00, 0x00, 0x00, 0x00,  // Code for char )
        0x00, 0x0A, 0x07, 0x0A, 0x00, 0x00, 0x00, 0x00,  // Code for char *
        0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00,  // Code for char +
        0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ,
        0x00, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00,  // Code for char -
        0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char .
        0x00, 0xC0, 0x3C, 0x03, 0x00, 0x00, 0x00, 0x00,  // Code for char /
        0x00, 0x7E, 0x81, 0x81, 0x81, 0x7E, 0x00, 0x00,  // Code for char 0
        0x00, 0x04, 0x02, 0xFF, 0x00, 0x00, 0x00, 0x00,  // Code for char 1
        0x00, 0x82, 0xC1, 0xA1, 0x91, 0x8E, 0x00, 0x00,  // Code for char 2
        0x00, 0x42, 0x81, 0x89, 0x89, 0x76, 0x00, 0x00,  // Code for char 3
        0x00, 0x30, 0x2C, 0x22, 0xFF, 0x20, 0x00, 0x00,  // Code for char 4
        0x00, 0x4C, 0x8B, 0x89, 0x89, 0x71, 0x00, 0x00,  // Code for char 5
        0x00, 0x7E, 0x89, 0x89, 0x89, 0x72, 0x00, 0x00,  // Code for char 6
        0x00, 0x01, 0xE1, 0x19, 0x07, 0x01, 0x00, 0x00,  // Code for char 7
        0x00, 0x76, 0x89, 0x89, 0x89, 0x76, 0x00, 0x00,  // Code for char 8
        0x00, 0x4E, 0x91, 0x91, 0x91, 0x7E, 0x00, 0x00,  // Code for char 9
        0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char :
        0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ;
        0x00, 0x10, 0x28, 0x28, 0x28, 0x44, 0x00, 0x00,  // Code for char <
        0x00, 0x28, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00,  // Code for char =
        0x00, 0x44, 0x28, 0x28, 0x28, 0x10, 0x00, 0x00,  // Code for char >
        0x00, 0x02, 0x01, 0xB1, 0x09, 0x06, 0x00, 0x00,  // Code for char ?
        0x00, 0xF8, 0x06, 0x72, 0x89, 0x85, 0x45, 0xF9,  // Code for char @
        0x00, 0xC0, 0x30, 0x2E, 0x21, 0x2E, 0x30, 0xC0,  // Code for char A
        0x00, 0xFF, 0x89, 0x89, 0x89, 0x89, 0x7E, 0x00,  // Code for char B
        0x00, 0x3C, 0x42, 0x81, 0x81, 0x81, 0x42, 0x00,  // Code for char C
        0x00, 0xFF, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00,  // Code for char D
        0x00, 0xFF, 0x89, 0x89, 0x89, 0x89, 0x00, 0x00,  // Code for char E
        0x00, 0xFF, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00,  // Code for char F
        0x00, 0x3C, 0x42, 0x81, 0x81, 0x91, 0x52, 0x34,  // Code for char G
        0x00, 0xFF, 0x08, 0x08, 0x08, 0x08, 0xFF, 0x00,  // Code for char H
        0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char I
        0x00, 0x60, 0x80, 0x80, 0x7F, 0x00, 0x00, 0x00,  // Code for char J
        0x00, 0xFF, 0x10, 0x08, 0x1C, 0x62, 0x81, 0x00,  // Code for char K
        0x00, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00,  // Code for char L
        0x00, 0xFF, 0x06, 0x38, 0xC0, 0x38, 0x06, 0xFF,  // Code for char M
        0x00, 0xFF, 0x02, 0x0C, 0x30, 0x40, 0xFF, 0x00,  // Code for char N
        0x00, 0x3C, 0x42, 0x81, 0x81, 0x81, 0x42, 0x3C,  // Code for char O
        0x00, 0xFF, 0x11, 0x11, 0x11, 0x0E, 0x00, 0x00,  // Code for char P
        0x00, 0x3C, 0x42, 0x81, 0xA1, 0xA1, 0x42, 0xBC,  // Code for char Q
        0x00, 0xFF, 0x09, 0x09, 0x19, 0x69, 0x86, 0x00,  // Code for char R
        0x00, 0x46, 0x89, 0x89, 0x91, 0x91, 0x62, 0x00,  // Code for char S
        0x00, 0x01, 0x01, 0xFF, 0x01, 0x01, 0x00, 0x00,  // Code for char T
        0x00, 0x7F, 0x80, 0x80, 0x80, 0x80, 0x7F, 0x00,  // Code for char U
        0x00, 0x03, 0x0C, 0x30, 0xC0, 0x30, 0x0C, 0x03,  // Code for char V
        0x00, 0x3C, 0xC0, 0x30, 0x0E, 0x01, 0x0E, 0x30,  // Code for char W
        0x00, 0x81, 0x66, 0x18, 0x18, 0x66, 0x81, 0x00,  // Code for char X
        0x00, 0x01, 0x06, 0x08, 0xF0, 0x08, 0x06, 0x01,  // Code for char Y
        0x00, 0x80, 0xC1, 0xB1, 0x8D, 0x83, 0x81, 0x00,  // Code for char Z
        0x00, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char [
        0x00, 0x03, 0x3C, 0xC0, 0x00, 0x00, 0x00, 0x00,  // Code for char BackSlash
        0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ]
        0x00, 0x08, 0x06, 0x01, 0x06, 0x08, 0x00, 0x00,  // Code for char ^
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char _
        0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char `
        0x00, 0x68, 0x94, 0x94, 0x54, 0xF8, 0x00, 0x00,  // Code for char a
        0x00, 0xFF, 0x48, 0x84, 0x84, 0x78, 0x00, 0x00,  // Code for char b
        0x00, 0x78, 0x84, 0x84, 0x84, 0x48, 0x00, 0x00,  // Code for char c
        0x00, 0x78, 0x84, 0x84, 0x48, 0xFF, 0x00, 0x00,  // Code for char d
        0x00, 0x78, 0x94, 0x94, 0x94, 0x58, 0x00, 0x00,  // Code for char e
        0x00, 0x04, 0xFE, 0x05, 0x00, 0x00, 0x00, 0x00,  // Code for char f
        0x00, 0x78, 0x84, 0x84, 0x48, 0xFC, 0x00, 0x00,  // Code for char g
        0x00, 0xFF, 0x08, 0x04, 0x04, 0xF8, 0x00, 0x00,  // Code for char h
        0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char i
        0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char j
        0x00, 0xFF, 0x10, 0x68, 0x84, 0x00, 0x00, 0x00,  // Code for char k
        0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char l
        0x00, 0xFC, 0x08, 0x04, 0xFC, 0x04, 0x04, 0xF8,  // Code for char m
        0x00, 0xFC, 0x04, 0x04, 0x04, 0xF8, 0x00, 0x00,  // Code for char n
        0x00, 0x78, 0x84, 0x84, 0x84, 0x78, 0x00, 0x00,  // Code for char o
        0x00, 0xFC, 0x48, 0x84, 0x84, 0x78, 0x00, 0x00,  // Code for char p
        0x00, 0x78, 0x84, 0x84, 0x48, 0xFC, 0x00, 0x00,  // Code for char q
        0x00, 0xFC, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00,  // Code for char r
        0x00, 0x48, 0x94, 0x94, 0xA4, 0x48, 0x00, 0x00,  // Code for char s
        0x00, 0xFF, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char t
        0x00, 0x7C, 0x80, 0x80, 0x40, 0xFC, 0x00, 0x00,  // Code for char u
        0x00, 0x0C, 0x30, 0xC0, 0x30, 0x0C, 0x00, 0x00,  // Code for char v
        0x00, 0x0C, 0x30, 0xC0, 0x38, 0x04, 0x38, 0xC0,  // Code for char w
        0x00, 0x84, 0x48, 0x30, 0x48, 0x84, 0x00, 0x00,  // Code for char x
        0x00, 0x0C, 0x30, 0xC0, 0x30, 0x0C, 0x00, 0x00,  // Code for char y
        0x00, 0x84, 0xC4, 0xB4, 0x8C, 0x84, 0x00, 0x00,  // Code for char z
        0x00, 0x10, 0xEE, 0x01, 0x00, 0x00, 0x00, 0x00,  // Code for char {
        0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char |
        0x00, 0x00, 0x01, 0xEE, 0x10, 0x00, 0x00, 0x00,  // Code for char }
        0x00, 0x18, 0x08, 0x18, 0x10, 0x08, 0x00, 0x00,  // Code for char ~
        0x00, 0xFF, 0x81, 0xFF, 0x00, 0x00, 0x00, 0x00   // Code for char 
        };


void write_string8Line(char str[]){
unsigned char temp[8];
unsigned char data[32][8];
int k;
int i;
int j;
int counter;
int c;

    int len = strlen(str);
    for(i=0; i<32; i++){
       if(i>=len)
        for(j=0;j<8;j++) 
            data[i][j]=0;
    }

for(k=0; k<len; k++){    
    c = str[k];
    c-=32;
    c*=8;
     
    for(i=0; i<8; i++){
        temp[i]=Arial[c+(7-i)];
    }
       
    for(i=0; i<8; i++){
        for(j=0;j<8;j++){
            data[k][i] += temp[j]%2;
            if(j!=7)
                data[k][i] = data[k][i] << 1;
            temp[j]/=2;
        } 
    }
 }
    for(i=0; i<8; i++){ 
        for(k=0; k<32; k++){
           write_data(data[k][i]);
        }
    }
}                   
void write_space(){
    int k;
    for(k=0; k<32; k++){
        write_data(0);
    }
}

void write_data(unsigned char data){

PORTD.E = 0;
#asm("nop")
PORTA = 0x0C;
PORTD = (0<<RW)|(1<<RS);
PORTD.E = 1;
#asm("nop")
#asm("nop")
//delay_ms(1);
PORTD.E = 0;
#asm("nop")
PORTA = data;
PORTD = (0<<RW)|(0<<RS);
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
PORTD.E = 0;
#asm("nop")

}

unsigned char read_data(){
    //read data (after set cursor first read is not valid second read is correct)
 unsigned char data;
PORTD.E = 0;
PORTA = 0x0D;
PORTD = (0<<RW)|(1<<RS);
PORTD.E = 1;
//delay_ms(1);
PORTD.E = 0;
DDRA = 0x00;
PORTD = (1<<RW)|(0<<RS);
PORTD.E = 1;
//delay_ms(1);
PORTD.E = 0;
data = PINA;
DDRA = 0xFF;
return data;
}

void set_bit(unsigned char data){

PORTD.E = 0;
#asm("nop")
PORTA = 0x0F;
PORTD = (0<<RW)|(1<<RS);
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
PORTD.E = 0;
#asm("nop")
PORTA = data; //0-8
PORTD = (0<<RW)|(0<<RS);
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
PORTD.E = 0;
#asm("nop")

}

void clear_bit(unsigned char data){

PORTD.E = 0;
#asm("nop")
PORTA = 0x0E;
PORTD = (0<<RW)|(1<<RS);
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
PORTD.E = 0;
#asm("nop")
PORTA = data; //0-8
PORTD = (0<<RW)|(0<<RS);
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
PORTD.E = 0;
#asm("nop")

}

void cursor_setLowAddress(unsigned char data){
   //cursor low address
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0x0A;
PORTD = (0<<RW)|(1<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = data;
PORTD = (0<<RW)|(0<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")

}
void cursor_setHighAddress(unsigned char data){
       //cursor high address
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0x0B;
PORTD = (0<<RW)|(1<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = data;
PORTD = (0<<RW)|(0<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")

}

void init(){

 //goto graphic mode
PORTD.E = 0;
#asm("nop")
PORTA = 0x00;
PORTD = (0<<RW)|(1<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0b00110010;
PORTD = (0<<RW)|(0<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")

//bit of byte
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0x01;
PORTD = (0<<RW)|(1<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0x07;
PORTD = (0<<RW)|(0<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")

//byte in horizontal
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0x02;
PORTD = (0<<RW)|(1<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 31;
PORTD = (0<<RW)|(0<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")

//display time divition(1/rate)  => rows
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0x03;
PORTD = (0<<RW)|(1<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0b01000000;
PORTD = (0<<RW)|(0<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")

//display start low order address
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0x08;
PORTD = (0<<RW)|(1<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0b00000000;
PORTD = (0<<RW)|(0<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")

//display start high order address
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0x09;
PORTD = (0<<RW)|(1<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")
PORTA = 0b00000000;
PORTD = (0<<RW)|(0<<RS);
#asm("nop")
PORTD.E = 1;
#asm("nop")
//delay_ms(1);
#asm("nop")
PORTD.E = 0;
#asm("nop")

cursor_setLowAddress(0);
cursor_setHighAddress(0);
                  
}

void moreSettings(){
//write data, cursor increases automatically
//write_data(0b10101010);

 //read data (after set cursor first read is not valid second read is correct)
/*
PORTD.E = 0;
PORTA = 0x0D;
PORTD = (0<<RW)|(1<<RS);
PORTD.E = 1;
//delay_ms(1);
PORTD.E = 0;
DDRA = 0x00;
PORTD = (1<<RW)|(0<<RS);
PORTD.E = 1;
//delay_ms(1);
PORTD.E = 0;
unsigned char data = PINA
DDRA = 0xFF; 
*/

//clear a bit, cursor increases automatically
/*
PORTD.E = 0;
PORTA = 0x0E;
PORTD = (0<<RW)|(1<<RS);
PORTD.E = 1;
//delay_ms(1);
PORTD.E = 0;
PORTA = 0b00000001; //0-8
PORTD = (0<<RW)|(0<<RS);
PORTD.E = 1;
//delay_ms(1);
PORTD.E = 0;
*/

//set a bit, cursor increases automatically
/*
PORTD.E = 0;
PORTA = 0x0F;
PORTD = (0<<RW)|(1<<RS);
PORTD.E = 1;
//delay_ms(1);
PORTD.E = 0;
PORTA = 0b00000001; //0-8
PORTD = (0<<RW)|(0<<RS);
PORTD.E = 1;
//delay_ms(1);
PORTD.E = 0;
*/

//read busy flag, just when write instruction(RS=1) check it
/*
PORTD.E = 0;
DDRA = 0x00;
PORTD = (1<<RW)|(1<<RS);
PORTD.E = 1;
//delay_ms(1);
PORTD.E = 0;
unsigned char b = PINA;// just PINA.7 is busy flag
DDRA = 0xFF;
*/
}

void screenReset(){
int counter=0;
    while(counter < 2048){
      write_data(0);
      counter++;
    }
}

void main(void)
{
// Declare your local variables here

DDRD = 0xFF;
DDRA = 0xFF;

// USART initialization
// Communication Parameters: 8 Data, 1 Stop, No Parity
// USART Receiver: On
// USART Transmitter: Off
// USART Mode: Asynchronous
// USART Baud Rate: 9600 (Double Speed Mode)
UCSRA=(0<<RXC) | (0<<TXC) | (0<<UDRE) | (0<<FE) | (0<<DOR) | (0<<UPE) | (1<<U2X) | (0<<MPCM);
UCSRB=(1<<RXCIE) | (0<<TXCIE) | (0<<UDRIE) | (1<<RXEN) | (0<<TXEN) | (0<<UCSZ2) | (0<<RXB8) | (0<<TXB8);
UCSRC=(1<<URSEL) | (0<<UMSEL) | (0<<UPM1) | (0<<UPM0) | (0<<USBS) | (1<<UCSZ1) | (1<<UCSZ0) | (0<<UCPOL);
UBRRH=0x00;
UBRRL=0x0C;

// Global enable interrupts
#asm("sei")

//delay_ms(1000); 
init();

screenReset();
strcpy(string, "this is a test");
write_string8Line(string); 
  
while (1)
      { 
        idle();
      }
}
